/**
 * queued message exchange
 */
class QueuedExchangeContextImpl<T> {

	/**
	 * Exchange timeout in seconds
	 */
	private static final long EXCHANGE_TIMEOUT = 50;

	private final java.util.concurrent.Exchanger<Exception> exceptionExchange =
		new java.util.concurrent.Exchanger<Exception>();
	private final java.util.concurrent.CountDownLatch latch =
		new java.util.concurrent.CountDownLatch(1);

	private final T input;

	private T output = null;
//	private T faultDetails = null;
	private Throwable fault = null;
//	private String faultMessage = null;

	public QueuedExchangeContextImpl(T inMsg) {
		this.input = inMsg;
	}

	/**
	 * Don't forget to call this method when you are done
	 * with processing of the {@link QueuedExchangeContext}
	 */
	public void release() throws Exception {
		latch.countDown();
		Exception exception;
		try {
			exception = exceptionExchange.exchange(null, EXCHANGE_TIMEOUT,
					java.util.concurrent.TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			throw new Exception(e);
		} catch (java.util.concurrent.TimeoutException e) {
			throw new Exception(e);
		}
		if (exception != null) {
			throw exception;
		}
	}

	/**
	 * This operation have to be called on the Web Service
	 * thread to send response if required
	 *
	 * @throws InterruptedException
	 */
	public void completeQueuedProcessing() throws InterruptedException {
		exceptionExchange.exchange(null);
	}

	/**
	 * @throws InterruptedException
	 */
	void waitForRelease(long timeout, java.util.concurrent.TimeUnit unit)
			throws InterruptedException {
		latch.await(timeout, unit);
	}

	public T getInputMessage() {
		return input;
	}

	public void serveOutputMessage(T response) {
		output = response;
	}

//	public void serveBusinessFault(String faultMessage, T faultDetails) {
//		this.faultMessage =
//			(null == faultMessage || 0 == faultMessage.trim().length())
//				? "Talend job business fault" : faultMessage;
//		this.faultDetails = faultDetails;
//	}
//
//	public void serveFault(String faultMessage, Throwable fault) {
//		this.faultMessage =
//			(null == faultMessage || 0 == faultMessage.trim().length())
//				? "Talend job error" : faultMessage;
//		this.fault = fault;
//	}

	public void serveFault(Throwable fault) {
		this.fault = fault;
	}

	public boolean isFault() {
//		return (faultMessage != null);
		return fault != null;
	}

//	public boolean isBusinessFault() {
//		return isFault() && null == fault;
//	}

	public T getResponse() {
		return output;
	}

//	public String getFaultMessage() {
//		return faultMessage;
//	}
//
//	public T getBusinessFaultDetails() {
//		return faultDetails;
//	}

	public Throwable getFault() {
		return fault;
	}

}

/**
 * message exchange controller
 */
class QueuedMessageHandlerImpl<T> implements ESBProviderCallback {
	private final int MAX_QUEUE_SIZE = 1000;

	private final int WAIT_TIMEOUT_SECONDS = 120;

	private final java.util.concurrent.BlockingQueue<QueuedExchangeContextImpl<?>> queue =
		new java.util.concurrent.LinkedBlockingQueue<QueuedExchangeContextImpl<?>>(MAX_QUEUE_SIZE);

	/**
	 * This method add a newly created
	 * {@link QueuedExchangeContextImpl} into the internal
	 * blocking queue where consumer thread is waiting for it.
	 * Then it waits until the {@link QueuedExchangeContextImpl}
	 * will be completed for request-response operations
	 */
	public QueuedExchangeContextImpl<T> invoke(T request) {
		QueuedExchangeContextImpl<T> context =
			new QueuedExchangeContextImpl<T>(request);
		boolean inserted = queue.offer(context);
		if (!inserted) {
			try {
				context.release();
			} catch (Exception e) {
				e.printStackTrace();
			}
			// context.serveFault("job pool overflow exceed", null);
			throw new RuntimeException(
					"Can't queue request, queue size of "
							+ MAX_QUEUE_SIZE + " is exceeded");
		} else {
			try {
				context.waitForRelease(WAIT_TIMEOUT_SECONDS,
						java.util.concurrent.TimeUnit.SECONDS);
			} catch (InterruptedException ie) {
				// context.serveFault("job execution timeout", ie);
				throw new RuntimeException(
						"job execution timeout: " + ie.getMessage());
			}
		}
		return context;
	}

	QueuedExchangeContextImpl<T> currentExchangeContext;

	public T getRequest() throws ESBJobInterruptedException {
		currentExchangeContext = null;
		try {
			currentExchangeContext = (QueuedExchangeContextImpl<T>) queue.take();
		} catch (InterruptedException e) {
			// e.printStackTrace();
			throw new RuntimeException(e);
		}
		return currentExchangeContext.getInputMessage();
	}

	public void sendResponse(Object output) {
		if (null == currentExchangeContext) {
			throw new RuntimeException("sendResponse() invoked before getRequest()");
		}

//		// business fault
//		if (output instanceof ProviderFault) {
//			ProviderFault providerFault = (ProviderFault) output;
//			currentExchangeContext.serveBusinessFault(
//					providerFault.getMessage(), (T) providerFault.getDetail());
//		}
//
//		// job error
//		if (output instanceof Exception) {
//			currentExchangeContext.serveFault(
//					"Talend job execution error", (Throwable) output);
//		}
//
//		// payload
//		currentExchangeContext.serveOutputMessage((T) output);

		if (output instanceof Throwable) {
			// fault
			currentExchangeContext.serveFault((Throwable) output);
		} else {
			// response
			currentExchangeContext.serveOutputMessage((T) output);
		}

		try {
			currentExchangeContext.release();
		} catch (Exception e) {
			// e.printStackTrace();
			throw new RuntimeException(e);
		}
	}
}

/**
 * web service provider implementation
 */
<%
	String projectName = codeGenArgument.getCurrentProjectName();
	String processName = node.getProcess().getName();

	String methodName = ElementParameterParser.getValue(node,"__METHOD__");
	methodName = methodName.split("\\(")[0];
	String serviceNS = ElementParameterParser.getValue(node,"__SERVICE_NS__");
	String serviceName = ElementParameterParser.getValue(node,"__SERVICE_NAME__");
	if ("--DEFAULT--".equals(serviceName)) {
		serviceName = projectName+"_"+processName;
	}
	String portName = ElementParameterParser.getValue(node,"__PORT_NAME__");
	if ("--DEFAULT--".equals(portName)) {
		portName = serviceName+"_Port";
	}
%>
@javax.jws.WebService(
		name = "<%=serviceName%>",
		targetNamespace = "<%=serviceNS%>"
	)
@javax.jws.soap.SOAPBinding(
		parameterStyle = javax.jws.soap.SOAPBinding.ParameterStyle.BARE
	)
@javax.xml.ws.ServiceMode(
		value = javax.xml.ws.Service.Mode.PAYLOAD
	)
@javax.xml.ws.WebServiceProvider()
class ESBProvider_<%=cid%> implements
		javax.xml.ws.Provider<javax.xml.transform.Source> {

	private javax.xml.transform.TransformerFactory factory =
		javax.xml.transform.TransformerFactory.newInstance();
	private QueuedMessageHandlerImpl<org.dom4j.Document> messageHandler;

	private final String TNS = ESBProvider_<%=cid%>.class.getAnnotation(
			javax.jws.WebService.class).targetNamespace();

	public ESBProvider_<%=cid%>(
			QueuedMessageHandlerImpl<org.dom4j.Document> messageHandler) {
		this.messageHandler = messageHandler;
	}
	<%

	%>
	@javax.jws.WebMethod(
			operationName = "<%=methodName%>",
			action = "<%=serviceNS%>/<%=methodName%>"
		)
<% if (isOneWay) { %>
	@javax.jws.Oneway()
<% } else { %>
	@javax.jws.WebResult(
			name = "<%=methodName%>Output",
			targetNamespace = "<%=serviceNS%>",
			partName = "response"
		)
<% } %>
	public javax.xml.transform.Source invoke(
			@javax.jws.WebParam(
					name = "<%=methodName%>Input",
					targetNamespace = "<%=serviceNS%>",
					partName = "request"
				) javax.xml.transform.Source request) {

		// System.out.println(System.currentTimeMillis() + " -> handleMessage");

		try {
			org.dom4j.io.DocumentResult docResult = new org.dom4j.io.DocumentResult();
			factory.newTransformer().transform(request, docResult);
			org.dom4j.Document requestDoc = docResult.getDocument();
			// System.out.println("request: " + requestDoc.asXML());

			QueuedExchangeContextImpl<org.dom4j.Document> messageExchange =
				messageHandler.invoke(requestDoc);

			try {
<% if (isOneWay) { %>
				return null;
<% } else { %>
				if (messageExchange.isFault()) {
					throw messageExchange.getFault();

//					String faultString = messageExchange.getFaultMessage();
//					// System.out.println("fault: " + faultString);
//
//					if (messageExchange.isBusinessFault()) {
//						org.dom4j.Document faultDoc = messageExchange.getBusinessFaultDetails();
//						javax.xml.soap.SOAPFactory soapFactory =
//							javax.xml.soap.SOAPFactory.newInstance();
//						javax.xml.soap.SOAPFault soapFault =
//							soapFactory.createFault(faultString,
//									new javax.xml.namespace.QName(TNS, "businessFault"));
//						if (null != faultDoc) {
//							// System.out.println("business fault details: " + faultDoc.asXML());
//							org.dom4j.io.DOMWriter writer = new org.dom4j.io.DOMWriter();
//							org.w3c.dom.Document faultDetailDom = writer.write(faultDoc);
//							soapFault.addDetail().appendChild(
//									soapFault.getOwnerDocument().importNode(
//											faultDetailDom.getDocumentElement(), true));
//						}
//						throw new javax.xml.ws.soap.SOAPFaultException(soapFault);
//					} else {
//						Throwable error = messageExchange.getFault();
//						// System.out.println("job error: " + error.getMessage());
//						if (error instanceof RuntimeException) {
//							throw (RuntimeException) error;
//						} else {
//							throw new RuntimeException(faultString, error);
//						}
//					}
				} else {
					org.dom4j.Document responseDoc = messageExchange.getResponse();
					if (null == responseDoc) {
						// System.out.println("response: empty");
						throw new RuntimeException("no response provided by Talend job");
					}
					// System.out.println("response: " + responseDoc.asXML());

					return new org.dom4j.io.DocumentSource(responseDoc);
				}
<% } %>
			} finally {
				messageExchange.completeQueuedProcessing();
			}

		} catch (RuntimeException ex) {
			throw ex;
		} catch (Throwable ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		} finally {
			// System.out.println(System.currentTimeMillis() + " <- handleMessage");
		}
	}
}

class ESBProviderCallbackTalendJobWrapper_<%=cid%> implements ESBProviderCallbackTalendJobInner {

	private final String TNS = ESBProvider_<%=cid%>.class.getAnnotation(
			javax.jws.WebService.class).targetNamespace();

	private ESBProviderCallback esbProviderCallback;

	public ESBProviderCallbackTalendJobWrapper_<%=cid%>(ESBProviderCallback callback) {
		esbProviderCallback = callback;
	}

	public Object getRequest() throws ESBJobInterruptedException {
		return esbProviderCallback.getRequest();
	}

	public void sendResponse(Object response) {
		esbProviderCallback.sendResponse(response);
	}

	public void sendFault(Throwable error) {
		RuntimeException talendJobError;
		if (error instanceof RuntimeException) {
			talendJobError = (RuntimeException) error;
		} else {
			talendJobError = new RuntimeException(
					"Talend job execution error", error);
		}
		esbProviderCallback.sendResponse(talendJobError);
	}

	public void sendBusinessFault(String faultString,
			org.dom4j.Document faultDetail) {

		try {
			javax.xml.soap.SOAPFactory soapFactory =
				javax.xml.soap.SOAPFactory.newInstance();
			javax.xml.soap.SOAPFault soapFault = soapFactory.createFault(
					faultString, new javax.xml.namespace.QName(TNS, "businessFault"));
			if (null != faultDetail) {
				// System.out.println("business fault details: " + faultDoc.asXML());
				org.dom4j.io.DOMWriter writer = new org.dom4j.io.DOMWriter();
				org.w3c.dom.Document faultDetailDom = writer.write(faultDetail);
				soapFault.addDetail().appendChild(
						soapFault.getOwnerDocument().importNode(
								faultDetailDom.getDocumentElement(), true));
			}
			esbProviderCallback.sendResponse(
					new javax.xml.ws.soap.SOAPFaultException(soapFault)
			);
		} catch (Exception e) {
			this.sendFault(e);
		}
	}
}

class HandlerThread_<%=cid%> extends Thread {

	private final String TNS = ESBProvider_<%=cid%>.class.getAnnotation(
			javax.jws.WebService.class).targetNamespace();

	private javax.xml.ws.Endpoint endpoint;
	QueuedMessageHandlerImpl<org.dom4j.Document> handler;

	public HandlerThread_<%=cid%>(
			QueuedMessageHandlerImpl<org.dom4j.Document> handler) {
		this.handler = handler;
	}

	public void run() {
		ESBProvider_<%=cid%> esbProvider = new ESBProvider_<%=cid%>(handler);

		endpoint = javax.xml.ws.Endpoint.create(esbProvider);
		@SuppressWarnings("serial")
		java.util.Map<String, Object> map = new java.util.HashMap<String, Object>() {{
			put(javax.xml.ws.Endpoint.WSDL_SERVICE,
					new javax.xml.namespace.QName(TNS, "<%=serviceName%>"));
			put(javax.xml.ws.Endpoint.WSDL_PORT,
					new javax.xml.namespace.QName(TNS, "<%=portName%>")); //
		}};
		endpoint.setProperties(map);
		endpoint.publish(endpointUrl);

		System.out.println("web service [endpoint: " + endpointUrl + "] published");
	}

	public void stopEndpoint() {
		if (null != endpoint) {
			endpoint.stop();
			System.out.println("web service [endpoint: " + endpointUrl + "] unpublished");
		}
	}
}
