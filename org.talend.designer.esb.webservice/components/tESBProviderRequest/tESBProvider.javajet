/**
 * queued message exchange
 */
class QueuedExchangeContextImpl<T> {

	/**
	 * Exchange timeout in seconds
	 */
	private static final long EXCHANGE_TIMEOUT = 50;

	private final java.util.concurrent.Exchanger<Exception> exceptionExchange =
		new java.util.concurrent.Exchanger<Exception>();
	private final java.util.concurrent.CountDownLatch latch =
		new java.util.concurrent.CountDownLatch(1);

	private final T input;

	private T output = null;
	private T faultDetails = null;
	private Throwable fault = null;
	private String faultMessage = null;

	public QueuedExchangeContextImpl(T inMsg) {
		this.input = inMsg;
	}

	/**
	 * Don't forget to call this method when you are done
	 *  with processing of the {@link QueuedExchangeContext}
	 */
	public void release() throws Exception {
		latch.countDown();
		Exception exception;
		try {
			exception = exceptionExchange.exchange(null, EXCHANGE_TIMEOUT,
					java.util.concurrent.TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			throw new Exception(e);
		} catch (java.util.concurrent.TimeoutException e) {
			throw new Exception(e);
		}
		if (exception != null) {
			throw exception;
		}
	}

	/**
	 * This operation have to be called on the Web Service
	 * thread to send response if required
	 *
	 * @throws InterruptedException
	 */
	public void completeQueuedProcessing() throws InterruptedException {
		exceptionExchange.exchange(null);
	}

	/**
	 * @throws InterruptedException
	 */
	void waitForRelease(long timeout, java.util.concurrent.TimeUnit unit)
			throws InterruptedException {
		latch.await(timeout, unit);
	}

	public T getInputMessage() {
		return input;
	}

	public void serveOutputMessage(T response) {
		output = response;
	}

	public void serveBusinessFault(String faultMessage, T faultDetails) {
		this.faultMessage =
			(null == faultMessage || 0 == faultMessage.trim().length())
				? "Talend job business fault" : faultMessage;
		this.faultDetails = faultDetails;
	}

	public void serveFault(String faultMessage, Throwable fault) {
		this.faultMessage =
			(null == faultMessage || 0 == faultMessage.trim().length())
				? "Talend job error" : faultMessage;
		this.fault = fault;
	}

	public boolean isFault() {
		return (faultMessage != null);
	}

	public boolean isBusinessFault() {
		return isFault() && null == fault;
	}
	
	public T getResponse() {
		return output;
	}

	public String getFaultMessage() {
		return faultMessage;
	}

	public T getBusinessFaultDetails() {
		return faultDetails;
	}

	public Throwable getFault() {
		return fault;
	}
	
}

/**
 * message exchange controller
 */
class QueuedMessageHandlerImpl<T> {
	private final int MAX_QUEUE_SIZE = 1000;

	private final int WAIT_TIMEOUT_SECONDS = 120;

	private final java.util.concurrent.BlockingQueue<QueuedExchangeContextImpl<?>> queue =
		new java.util.concurrent.LinkedBlockingQueue<QueuedExchangeContextImpl<?>>(MAX_QUEUE_SIZE);

	/**
	 * This method add a newly created
	 * {@link QueuedExchangeContextImpl} into the internal
	 * blocking queue where consumer thread is waiting for it.
	 * Then it waits until the {@link QueuedExchangeContextImpl}
	 * will be completed for request-response operations
	 */
	public QueuedExchangeContextImpl<T> invoke(T request) {
		QueuedExchangeContextImpl<T> context =
			new QueuedExchangeContextImpl<T>(request);
		boolean inserted = queue.offer(context);
		if (!inserted) {
			try {
				context.release();
			} catch (Exception e) {
				e.printStackTrace();
			}
			// context.serveFault("job pool overflow exceed", null);
			throw new RuntimeException(
					"Can't queue request, queue size of "
							+ MAX_QUEUE_SIZE + " is exceeded");
		} else {
			try {
				context.waitForRelease(WAIT_TIMEOUT_SECONDS,
						java.util.concurrent.TimeUnit.SECONDS);
			} catch (InterruptedException ie) {
				// context.serveFault("job execution timeout", ie);
				throw new RuntimeException(
						"job execution timeout: " + ie.getMessage());
			}
		}
		return context;
	}

	/**
	 * Blocking method to obtain the next message from the queue
	 *
	 * @return
	 * @throws InterruptedException
	 */
	@SuppressWarnings("unchecked")
	public QueuedExchangeContextImpl<T> next() throws InterruptedException {
		return (QueuedExchangeContextImpl<T>) queue.take();
	}

	public QueuedExchangeContextImpl<T> fetchNext() throws Exception {
		return next();
	}
}

/**
 * web service provider implementation
 */
@javax.jws.WebService(
		name = "TalendJobAsWebService",
		targetNamespace = "http://talend.org/esb/service/job"
	)
@javax.jws.soap.SOAPBinding(
		parameterStyle = javax.jws.soap.SOAPBinding.ParameterStyle.BARE
	)
@javax.xml.ws.ServiceMode(
		value = javax.xml.ws.Service.Mode.PAYLOAD
	)
@javax.xml.ws.WebServiceProvider()
class ESBProvider_<%=cid%> implements
		javax.xml.ws.Provider<javax.xml.transform.Source> {

	private javax.xml.transform.TransformerFactory factory =
		javax.xml.transform.TransformerFactory.newInstance();	
	private QueuedMessageHandlerImpl<org.dom4j.Document> messageHandler;

	private final String TNS = ESBProvider_<%=cid%>.class.getAnnotation(
			javax.jws.WebService.class).targetNamespace();

	public ESBProvider_<%=cid%>(
			QueuedMessageHandlerImpl<org.dom4j.Document> messageHandler) {
		this.messageHandler = messageHandler;
	}

	@javax.jws.WebMethod(
			operationName = "invoke",
			action = "http://talend.org/esb/service/job/invoke"
		)
<% if (isOneWay) { %>
	@javax.jws.Oneway()
<% } else { %>
	@javax.jws.WebResult(
			name = "jobOutput",
			targetNamespace = "http://talend.org/esb/service/job",
			// targetNamespace = "",
			partName = "response"
		)
<% } %>
	public javax.xml.transform.Source invoke(
			@javax.jws.WebParam(
					name = "jobInput",
					targetNamespace = "http://talend.org/esb/service/job",
					// targetNamespace = "",
					partName = "request"
				) javax.xml.transform.Source request) {

		// System.out.println(System.currentTimeMillis() + " -> handleMessage");

		try {
			org.dom4j.io.DocumentResult docResult = new org.dom4j.io.DocumentResult();
			factory.newTransformer().transform(request, docResult);
			org.dom4j.Document requestDoc = docResult.getDocument();
			// System.out.println("request: " + requestDoc.asXML());

			QueuedExchangeContextImpl<org.dom4j.Document> messageExchange =
				messageHandler.invoke(requestDoc);

			try {
<% if (isOneWay) { %>
				return null;
<% } else { %>
				if (messageExchange.isFault()) {
					String faultString = messageExchange.getFaultMessage();
					// System.out.println("fault: " + faultString);
					
					if (messageExchange.isBusinessFault()) {
						org.dom4j.Document faultDoc = messageExchange.getBusinessFaultDetails();
						javax.xml.soap.SOAPFactory soapFactory =
							javax.xml.soap.SOAPFactory.newInstance();
						javax.xml.soap.SOAPFault soapFault =
							soapFactory.createFault(faultString,
									new javax.xml.namespace.QName(TNS, "businessFault"));
						if (null != faultDoc) {
							// System.out.println("business fault details: " + faultDoc.asXML());
							org.dom4j.io.DOMWriter writer = new org.dom4j.io.DOMWriter();
							org.w3c.dom.Document faultDetailDom = writer.write(faultDoc);
							soapFault.addDetail().appendChild(
									soapFault.getOwnerDocument().importNode(
											faultDetailDom.getDocumentElement(), true));
						}
						throw new javax.xml.ws.soap.SOAPFaultException(soapFault);
					} else {
						Throwable error = messageExchange.getFault();
						// System.out.println("job error: " + error.getMessage());
						if (error instanceof RuntimeException) {
							throw (RuntimeException) error;
						} else {
							throw new RuntimeException(faultString, error);
						}
					}
				} else {
					org.dom4j.Document responseDoc = messageExchange.getResponse();
					// System.out.println("response: " + responseDoc.asXML());

					return new org.dom4j.io.DocumentSource(responseDoc);
				}
<% } %>
			} finally {
				messageExchange.completeQueuedProcessing();
			}

		} catch (RuntimeException ex) {
			throw ex;
		} catch (Throwable ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		} finally {
			// System.out.println(System.currentTimeMillis() + " <- handleMessage");
		}
	}
}

class HandlerThread_<%=cid%> extends Thread {

	private final String TNS = ESBProvider_<%=cid%>.class.getAnnotation(
			javax.jws.WebService.class).targetNamespace();

	private final String serviceName;

	private javax.xml.ws.Endpoint endpoint;
	QueuedMessageHandlerImpl<org.dom4j.Document> handler;

	public HandlerThread_<%=cid%>(
			QueuedMessageHandlerImpl<org.dom4j.Document> handler,
			String serviceName) {
		this.handler = handler;
		this.serviceName = serviceName;
	}

	public void run() {
		ESBProvider_<%=cid%> esbProvider = new ESBProvider_<%=cid%>(handler);

		endpoint = javax.xml.ws.Endpoint.create(esbProvider);
		@SuppressWarnings("serial")
		java.util.Map<String, Object> map = new java.util.HashMap<String, Object>() {{
			put(javax.xml.ws.Endpoint.WSDL_SERVICE,
					new javax.xml.namespace.QName(TNS, serviceName));
			put(javax.xml.ws.Endpoint.WSDL_PORT,
					new javax.xml.namespace.QName(TNS, serviceName + "SoapBinding"));
		}};
		endpoint.setProperties(map);
		endpoint.publish(endpointUrl);

		System.out.println("web service [endpoint: " + endpointUrl + "] published");
	}

	public void stopEndpoint() {
		if (null != endpoint) {
			endpoint.stop();
			System.out.println("web service [endpoint: " + endpointUrl + "] unpublished");
		}
	}
}
