<%@ jet
	package="org.talend.designer.codegen.translators.common"
	imports="
		java.util.List
		java.util.Map
		java.util.Vector

		org.talend.core.model.process.INode
		org.talend.core.model.process.IProcess
		org.talend.core.model.process.IConnection
		org.talend.core.model.process.IConnectionCategory
		org.talend.core.model.process.ElementParameterParser
		org.talend.designer.codegen.config.CodeGeneratorArgument
	"
	class="Header_additional"
%>
<%
CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
Vector v = (Vector) codeGenArgument.getArgument();
IProcess process = (IProcess) v.get(0);

boolean actAsProvider = !process.getNodesOfType("tESBProviderRequest").isEmpty();
boolean actAsConsumer = !process.getNodesOfType("tESBConsumer").isEmpty();

if (actAsProvider || actAsConsumer
	|| !process.getNodesOfType("tESBProviderResponse").isEmpty()
	|| !process.getNodesOfType("tESBProviderFault").isEmpty()) { %>
	interface ESBProviderCallbackTalendJobInner extends ESBProviderCallback {
		void setCustomProperties(java.util.Map<String, String> props);
		void sendFault(Throwable e);
		void sendBusinessFault(String faultString, org.dom4j.Document faultDetail);
	} <%
}

if (actAsProvider || actAsConsumer) { %>

	private ESBEndpointRegistry registry = null;
	private ESBProviderCallback callback = null;

	public void setEndpointRegistry(ESBEndpointRegistry registry) {
<% if (actAsConsumer) { %>		this.registry = registry;<% } %>
	}

	public void setProviderCallback(ESBProviderCallback callback) {
<% if (actAsProvider) { %>		this.callback = callback;<% } %>
	}


<% if (actAsProvider) {
	// Web Service Provider
	INode tESBProviderRequestNode = process.getNodesOfType("tESBProviderRequest").get(0);
	String tESBProviderRequestNodeCid = tESBProviderRequestNode.getUniqueName();

	String projectName = codeGenArgument.getCurrentProjectName();
	String processName = process.getName();

	String endpointUrl = ElementParameterParser.getValue(tESBProviderRequestNode, "__ESB_ENDPOINT__");

	String serviceNS = ElementParameterParser.getValue(tESBProviderRequestNode, "__SERVICE_NS__");
	String serviceName = ElementParameterParser.getValue(tESBProviderRequestNode, "__SERVICE_NAME__");
	if ("--DEFAULT--".equals(serviceName)) {
		serviceName = projectName + "_" + processName;
	}

	String portNS = ElementParameterParser.getValue(tESBProviderRequestNode, "__PORT_NS__");
	String portName = ElementParameterParser.getValue(tESBProviderRequestNode, "__PORT_NAME__");
	if ("--DEFAULT--".equals(portName)) {
		portName = serviceName + "_Port";
	}

	String methodName = ElementParameterParser.getValue(tESBProviderRequestNode, "__METHOD__");
	methodName = methodName.split("\\(")[0];

	boolean isOneWay = (process.getNodesOfType("tESBProviderFault").isEmpty()
		&& process.getNodesOfType("tESBProviderResponse").isEmpty());
	Boolean useSl = Boolean.valueOf(ElementParameterParser.getValue(tESBProviderRequestNode, "__SERVICE_LOCATOR__"));
	Boolean useSam = Boolean.valueOf(ElementParameterParser.getValue(tESBProviderRequestNode, "__SERVICE_ACTIVITY_MONITOR__"));
	%>
	public ESBEndpointInfo getEndpoint() {
		return new ESBEndpointInfo() {
			@SuppressWarnings("serial")
			private java.util.Map<String, Object> props = new java.util.HashMap<String, Object>() {{
				// "request-response" or "one-way"
				put("COMMUNICATION_STYLE", "<%=(isOneWay)?"one-way":"request-response"%>");
				//
				put("dataFormat", "PAYLOAD");
				put("portName", "{<%=portNS%>}<%=portName%>");
				put("serviceName", "{<%=serviceNS%>}<%=serviceName%>");
				put("defaultOperationName", "<%=methodName%>");
				// static
				put("defaultOperationNameSpace", "");
				// endpoint URI configured in tESBProviderInput
				put("publishedEndpointUrl", <%=endpointUrl%>);
 				// use Service Locator
				put("useServiceLocator", <%=useSl%>);
 				// use Service Activity Monitor
				put("useServiceActivityMonitor", <%=useSam%>);

		<% if (useSl) {
			List<Map<String, String>> customProperties = (List<Map<String,String>>)
					ElementParameterParser.getObjectValue(tESBProviderRequestNode, "__SERVICE_LOCATOR_CUSTOM_PROPERTIES__");
			if (!customProperties.isEmpty()) { %>
				// Service Locator custom properties
				java.util.Map<String, String> customProps_<%=tESBProviderRequestNodeCid%> = new java.util.HashMap<String, String>();
				<% for (int k = 0; k < customProperties.size(); k++) { %>
				customProps_<%=tESBProviderRequestNodeCid%>.put(<%=customProperties.get(k).get("PROP_NAME")%>, <%=customProperties.get(k).get("PROP_VALUE")%>);
				<% } %>
				put("SL-PROPS", customProps_<%=tESBProviderRequestNodeCid%>);
			<% } %>
		<% } %>
			}};

			public String getEndpointKey() {
				return "cxf";
			}

			public String getEndpointUri() {
				// projectName + "_" + processName
				return "<%=projectName%>_<%=processName%>";
			}

			public java.util.Map<String, Object> getEndpointProperties() {
				return props;
			}
		};
	}





/**
 * queued message exchange
 */
public class QueuedExchangeContextImpl<T> {

	/**
	 * Exchange timeout in seconds
	 */
	private static final long EXCHANGE_TIMEOUT = 50;

	private final java.util.concurrent.Exchanger<Exception> exceptionExchange =
		new java.util.concurrent.Exchanger<Exception>();
	private final java.util.concurrent.CountDownLatch latch =
		new java.util.concurrent.CountDownLatch(1);

	private final T input;

	private T output = null;
	private Throwable fault = null;

	public QueuedExchangeContextImpl(T inMsg) {
		this.input = inMsg;
	}

	/**
	 * Don't forget to call this method when you are done
	 * with processing of the {@link QueuedExchangeContext}
	 */
	public void release() throws Exception {
		latch.countDown();
		Exception exception;
		try {
			exception = exceptionExchange.exchange(null, EXCHANGE_TIMEOUT,
					java.util.concurrent.TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			throw new Exception(e);
		} catch (java.util.concurrent.TimeoutException e) {
			throw new Exception(e);
		}
		if (exception != null) {
			throw exception;
		}
	}

	/**
	 * This operation have to be called on the Web Service
	 * thread to send response if required
	 *
	 * @throws InterruptedException
	 */
	public void completeQueuedProcessing() throws InterruptedException {
		exceptionExchange.exchange(null);
	}

	/**
	 * @throws InterruptedException
	 */
	void waitForRelease(long timeout, java.util.concurrent.TimeUnit unit)
			throws InterruptedException {
		latch.await(timeout, unit);
	}

	public T getInputMessage() {
		return input;
	}

	public void serveOutputMessage(T response) {
		output = response;
	}

	public void serveFault(Throwable fault) {
		this.fault = fault;
	}

	public boolean isFault() {
		return fault != null;
	}

	public T getResponse() {
		return output;
	}

	public Throwable getFault() {
		return fault;
	}
}

/**
 * message exchange controller
 */
public class QueuedMessageHandlerImpl<T> implements ESBProviderCallback {
	private final int MAX_QUEUE_SIZE = 1000;

	private final int WAIT_TIMEOUT_SECONDS = 120;

	private final java.util.concurrent.BlockingQueue<QueuedExchangeContextImpl<?>> queue =
		new java.util.concurrent.LinkedBlockingQueue<QueuedExchangeContextImpl<?>>(MAX_QUEUE_SIZE);

	/**
	 * This method add a newly created
	 * {@link QueuedExchangeContextImpl} into the internal
	 * blocking queue where consumer thread is waiting for it.
	 * Then it waits until the {@link QueuedExchangeContextImpl}
	 * will be completed for request-response operations
	 */
	public QueuedExchangeContextImpl<T> invoke(T request) {
		QueuedExchangeContextImpl<T> context =
			new QueuedExchangeContextImpl<T>(request);
		boolean inserted = queue.offer(context);
		if (!inserted) {
			try {
				context.release();
			} catch (Exception e) {
				e.printStackTrace();
			}
			// context.serveFault("job pool overflow exceed", null);
			throw new RuntimeException(
					"Can't queue request, queue size of "
							+ MAX_QUEUE_SIZE + " is exceeded");
		} else {
			try {
				context.waitForRelease(WAIT_TIMEOUT_SECONDS,
						java.util.concurrent.TimeUnit.SECONDS);
			} catch (InterruptedException ie) {
				// context.serveFault("job execution timeout", ie);
				throw new RuntimeException(
						"job execution timeout: " + ie.getMessage());
			}
		}
		return context;
	}

	QueuedExchangeContextImpl<T> currentExchangeContext;

	public T getRequest() throws ESBJobInterruptedException {
		currentExchangeContext = null;
		try {
			currentExchangeContext = (QueuedExchangeContextImpl<T>) queue.take();
		} catch (InterruptedException e) {
			// e.printStackTrace();
			throw new RuntimeException(e);
		}
		return currentExchangeContext.getInputMessage();
	}

	public void sendResponse(Object output) {
		if (null == currentExchangeContext) {
			throw new RuntimeException("sendResponse() invoked before getRequest()");
		}

		if (output instanceof Throwable) {
			// fault
			currentExchangeContext.serveFault((Throwable) output);
		} else {
			// response
			currentExchangeContext.serveOutputMessage((T) output);
		}

		try {
			currentExchangeContext.release();
		} catch (Exception e) {
			// e.printStackTrace();
			throw new RuntimeException(e);
		}
	}
}

/**
 * web service provider implementation
 */
@javax.jws.WebService(
		name = "<%=serviceName%>",
		targetNamespace = "<%=serviceNS%>"
	)
@javax.jws.soap.SOAPBinding(
		parameterStyle = javax.jws.soap.SOAPBinding.ParameterStyle.BARE
	)
@javax.xml.ws.ServiceMode(
		value = javax.xml.ws.Service.Mode.PAYLOAD
	)
@javax.xml.ws.WebServiceProvider()
public class ESBProvider_<%=tESBProviderRequestNodeCid%> implements
		javax.xml.ws.Provider<javax.xml.transform.Source> {

	private javax.xml.transform.TransformerFactory factory =
		javax.xml.transform.TransformerFactory.newInstance();
	private QueuedMessageHandlerImpl<org.dom4j.Document> messageHandler;

	private final String TNS = ESBProvider_<%=tESBProviderRequestNodeCid%>.class.getAnnotation(
			javax.jws.WebService.class).targetNamespace();

	public ESBProvider_<%=tESBProviderRequestNodeCid%>(
			QueuedMessageHandlerImpl<org.dom4j.Document> messageHandler) {
		this.messageHandler = messageHandler;
	}
	<%

	%>
	@javax.jws.WebMethod(
			operationName = "<%=methodName%>",
			action = "<%=serviceNS%>/<%=methodName%>"
		)
<% if (isOneWay) { %>
	@javax.jws.Oneway()
<% } else { %>
	@javax.jws.WebResult(
			name = "<%=methodName%>Output",
			targetNamespace = "<%=serviceNS%>",
			partName = "response"
		)
<% } %>
	public javax.xml.transform.Source invoke(
			@javax.jws.WebParam(
					name = "<%=methodName%>Input",
					targetNamespace = "<%=serviceNS%>",
					partName = "request"
				) javax.xml.transform.Source request) {

		// System.out.println(System.currentTimeMillis() + " -> handleMessage");

		try {
			org.dom4j.io.DocumentResult docResult = new org.dom4j.io.DocumentResult();
			factory.newTransformer().transform(request, docResult);
			org.dom4j.Document requestDoc = docResult.getDocument();
			// System.out.println("request: " + requestDoc.asXML());

			QueuedExchangeContextImpl<org.dom4j.Document> messageExchange =
				messageHandler.invoke(requestDoc);

			try {
<% if (isOneWay) { %>
				return null;
<% } else { %>
				if (messageExchange.isFault()) {
					throw messageExchange.getFault();
				} else {
					org.dom4j.Document responseDoc = messageExchange.getResponse();
					if (null == responseDoc) {
						// System.out.println("response: empty");
						throw new RuntimeException("no response provided by Talend job");
					}
					// System.out.println("response: " + responseDoc.asXML());

					return new org.dom4j.io.DocumentSource(responseDoc);
				}
<% } %>
			} finally {
				messageExchange.completeQueuedProcessing();
			}

		} catch (RuntimeException ex) {
			throw ex;
		} catch (Throwable ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		} finally {
			// System.out.println(System.currentTimeMillis() + " <- handleMessage");
		}
	}
}

public class ESBProviderCallbackTalendJobWrapper_<%=tESBProviderRequestNodeCid%> implements ESBProviderCallbackTalendJobInner {

	private final String TNS = ESBProvider_<%=tESBProviderRequestNodeCid%>.class.getAnnotation(
			javax.jws.WebService.class).targetNamespace();

	private ESBProviderCallback esbProviderCallback;
	private java.util.Map<String, String> customProperty;

	public ESBProviderCallbackTalendJobWrapper_<%=tESBProviderRequestNodeCid%>(ESBProviderCallback callback) {
		esbProviderCallback = callback;
	}

	public Object getRequest() throws ESBJobInterruptedException {
		return esbProviderCallback.getRequest();
	}

	public void setCustomProperties(java.util.Map<String, String> props) {
		customProperty = props;
	}

	public void sendResponse(Object response) {
		esbProviderCallback.sendResponse(wrapOutput(response));
	}

	public void sendFault(Throwable error) {
		RuntimeException talendJobError;
		if (error instanceof RuntimeException) {
			talendJobError = (RuntimeException) error;
		} else {
			talendJobError = new RuntimeException(
					"Talend job execution error", error);
		}
		esbProviderCallback.sendResponse(talendJobError);
	}

	public void sendBusinessFault(String faultString,
			org.dom4j.Document faultDetail) {

		try {
			javax.xml.soap.SOAPFactory soapFactory =
				javax.xml.soap.SOAPFactory.newInstance();
			javax.xml.soap.SOAPFault soapFault = soapFactory.createFault(
					faultString, new javax.xml.namespace.QName(TNS, "businessFault"));
			if (null != faultDetail) {
				// System.out.println("business fault details: " + faultDoc.asXML());
				// A special version of DOMWriter that does not write xmlns:foo attributes
				org.dom4j.io.DOMWriter writer = new org.dom4j.io.DOMWriter() {
					protected void writeNamespace(org.w3c.dom.Element domElement, org.dom4j.Namespace namespace) {
						// Do nothing
					}
				};
				org.w3c.dom.Document faultDetailDom = writer.write(faultDetail);
				soapFault.addDetail().appendChild(
						soapFault.getOwnerDocument().importNode(
								faultDetailDom.getDocumentElement(), true));
			}
			esbProviderCallback.sendResponse(
					wrapOutput(new javax.xml.ws.soap.SOAPFaultException(soapFault)));
		} catch (Exception e) {
			this.sendFault(e);
		}
	}

	private Object wrapOutput(Object output) {
		if (esbProviderCallback instanceof QueuedMessageHandlerImpl) {
			return output;
		}
		return wrapPayload(output, customProperty);
	}
}

class HandlerThread_<%=tESBProviderRequestNodeCid%> extends Thread {

	private final String TNS = ESBProvider_<%=tESBProviderRequestNodeCid%>.class.getAnnotation(
			javax.jws.WebService.class).targetNamespace();

	private javax.xml.ws.Endpoint endpoint;
	QueuedMessageHandlerImpl<org.dom4j.Document> handler;

	final String endpointUrl = <%=endpointUrl%>;

	public HandlerThread_<%=tESBProviderRequestNodeCid%>(
			QueuedMessageHandlerImpl<org.dom4j.Document> handler) {
		this.handler = handler;
	}

	public void run() {
		ESBProvider_<%=tESBProviderRequestNodeCid%> esbProvider = new ESBProvider_<%=tESBProviderRequestNodeCid%>(handler);

		endpoint = javax.xml.ws.Endpoint.create(esbProvider);
		@SuppressWarnings("serial")
		java.util.Map<String, Object> map = new java.util.HashMap<String, Object>() {{
			put(javax.xml.ws.Endpoint.WSDL_SERVICE,
					new javax.xml.namespace.QName(TNS, "<%=serviceName%>"));
			put(javax.xml.ws.Endpoint.WSDL_PORT,
					new javax.xml.namespace.QName(TNS, "<%=portName%>")); //
		}};
		endpoint.setProperties(map);
		//test for busy
		java.net.ServerSocket ss = null;
		try {

			java.net.URL endpointURL = new java.net.URL(endpointUrl);
			String host = endpointURL.getHost();
			int port = endpointURL.getPort();
			if ("localhost".equals(host) || host.startsWith("127.0.0")) {
				try {
						ss = new java.net.ServerSocket(port);
				} catch (IOException e) {
					throw new IllegalArgumentException("Cannot start provider with uri: "+endpointUrl+". Port "+port+" already in use."); //rethrow exception
				} finally {
					if (ss != null) {
						try {
							ss.close();
						} catch (IOException e) {
							// ignore
						}
					}
				}
				try {
					//ok, let's doublecheck for silent listeners
					java.net.Socket cs = new java.net.Socket(host, port);
					//if succeed - somebody silently listening, fail!
					cs.close();
					throw new IllegalArgumentException("Cannot start provider with uri: "+endpointUrl+". Port "+port+" already in use."); //rethrow exception
				} catch (IOException e) {
					//ok, nobody listens, proceed
				}
			}
		} catch (java.net.MalformedURLException e) {
			throw new IllegalArgumentException("Cannot start provider with uri: "+endpointUrl+". Malformed URL."); //rethrow exception
		}
		endpoint.publish(endpointUrl);

		System.out.println("web service [endpoint: " + endpointUrl + "] published");
	}

	public void stopEndpoint() {
		if (null != endpoint) {
			endpoint.stop();
			System.out.println("web service [endpoint: " + endpointUrl + "] unpublished");
		}
	}
}





<% } else { // end if (actAsProvider) %>
	public ESBEndpointInfo getEndpoint() {
		return null;
	}
<% } %>

	private Object wrapPayload(Object payload, Object customProperties) {
		java.util.Map<String, Object> outputWrapped = new java.util.HashMap<String, Object>();
		outputWrapped.put("PAYLOAD", payload);
		if (null != customProperties) {
			outputWrapped.put("SAM-PROPS", customProperties);
		}
		return outputWrapped;
	}

<% } // end if (actAsProvider || actAsConsumer) %>



<% // REST
List<? extends INode> httpRequestComponentsList = process.getNodesOfType("tHTTPRequest");
if (!httpRequestComponentsList.isEmpty()) {

	INode tHTTPRequestNode = httpRequestComponentsList.get(0);
	String tHTTPRequestNodeCid = tHTTPRequestNode.getUniqueName();
%>
/**
 * queued message exchange
 */
class QueuedExchangeContextImpl<T> {

	/**
	 * Exchange timeout in seconds
	 */
	private static final long EXCHANGE_TIMEOUT = 50;

	private final java.util.concurrent.Exchanger<Exception> exceptionExchange =
		new java.util.concurrent.Exchanger<Exception>();
	private final java.util.concurrent.CountDownLatch latch =
		new java.util.concurrent.CountDownLatch(1);

	private final T input;

	private T output = null;

	public QueuedExchangeContextImpl(T input) {
		this.input = input;
	}

	/**
	 * Don't forget to call this method when you are done
	 * with processing of the {@link QueuedExchangeContext}
	 */
	public void release() throws Exception {
		latch.countDown();
		Exception exception;
		try {
			exception = exceptionExchange.exchange(null, EXCHANGE_TIMEOUT,
					java.util.concurrent.TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			throw new Exception(e);
		} catch (java.util.concurrent.TimeoutException e) {
			throw new Exception(e);
		}
		if (exception != null) {
			throw exception;
		}
	}

	/**
	 * This operation have to be called on the Web Service
	 * thread to send response if required
	 *
	 * @throws InterruptedException
	 */
	public void completeQueuedProcessing() throws InterruptedException {
		exceptionExchange.exchange(null);
	}

	/**
	 * @throws InterruptedException
	 */
	void waitForRelease(long timeout, java.util.concurrent.TimeUnit unit)
			throws InterruptedException {
		latch.await(timeout, unit);
	}

	public T getInput() {
		return input;
	}

	public void serveOutput(T response) {
		output = response;
	}

	public T getResponse() {
		return output;
	}
}

/**
 * message exchange controller
 */
class QueuedMessageHandlerImpl<T> implements ESBProviderCallback {
	private final int MAX_QUEUE_SIZE = 1000;

	private final int WAIT_TIMEOUT_SECONDS = 120;

	private final java.util.concurrent.BlockingQueue<QueuedExchangeContextImpl<?>> queue =
		new java.util.concurrent.LinkedBlockingQueue<QueuedExchangeContextImpl<?>>(MAX_QUEUE_SIZE);

	/**
	 * This method add a newly created
	 * {@link QueuedExchangeContextImpl} into the internal
	 * blocking queue where consumer thread is waiting for it.
	 * Then it waits until the {@link QueuedExchangeContextImpl}
	 * will be completed for request-response operations
	 */
	public QueuedExchangeContextImpl<T> invoke(T request) {
		QueuedExchangeContextImpl<T> context =
			new QueuedExchangeContextImpl<T>(request);
		boolean inserted = queue.offer(context);
		if (!inserted) {
			try {
				context.release();
			} catch (Exception e) {
				e.printStackTrace();
			}
			throw new RuntimeException(
					"Can't queue request, queue size of "
							+ MAX_QUEUE_SIZE + " is exceeded");
		} else {
			try {
				context.waitForRelease(WAIT_TIMEOUT_SECONDS,
						java.util.concurrent.TimeUnit.SECONDS);
			} catch (InterruptedException ie) {
				throw new RuntimeException(
						"job execution timeout: " + ie.getMessage());
			}
		}
		return context;
	}

	QueuedExchangeContextImpl<T> currentExchangeContext;

	public T getRequest() throws ESBJobInterruptedException {
		currentExchangeContext = null;
		try {
			currentExchangeContext = (QueuedExchangeContextImpl<T>) queue.take();
		} catch (InterruptedException e) {
			throw new RuntimeException(e);
		}
		return currentExchangeContext.getInput();
	}

	public void sendResponse(Object output) {
		if (null == currentExchangeContext) {
			throw new RuntimeException("sendResponse() invoked before getRequest()");
		}

		currentExchangeContext.serveOutput((T) output);

		try {
			currentExchangeContext.release();
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}
}

/**
 * REST provider implementation
 */
@javax.ws.rs.Path("/")
@javax.ws.rs.Produces("text/plain")
@javax.ws.rs.Consumes("text/plain")
public class RESTProvider_<%=tHTTPRequestNodeCid%> {

	private QueuedMessageHandlerImpl<java.util.Map<String, Object>> messageHandler;

	public RESTProvider_<%=tHTTPRequestNodeCid%>(
			QueuedMessageHandlerImpl<java.util.Map<String, Object>> messageHandler) {
		this.messageHandler = messageHandler;
	}

	private java.util.Map<String, String> getPathParameters(javax.ws.rs.core.UriInfo uriInfo) {
		java.util.Map<String, String> params = new java.util.HashMap<String, String>();
		javax.ws.rs.core.MultivaluedMap<String, String> pathParams = uriInfo.getPathParameters();
		for (String paramName : pathParams.keySet()) {
			params.put(paramName, pathParams.getFirst(paramName));
		}
		return params;
	}

<%
List<? extends IConnection> conns = tHTTPRequestNode.getOutgoingSortedConnections();
if (null != conns && !conns.isEmpty()) {
	boolean isOneWay2 = tHTTPRequestNode.getProcess().getNodesOfType("tHTTPResponse").isEmpty();
	List<Map<String, String>> mappings = (List<Map<String, String>>) ElementParameterParser.getObjectValue(tHTTPRequestNode, "__SCHEMAS__");
	for (IConnection conn : conns) {
		if (conn.getLineStyle().hasConnectionCategory(IConnectionCategory.DATA)) {
			String connName = conn.getName();
			String httpVerb = null;
			String uriPattern = null;

			boolean foundMapping = false;
			for (Map<String, String> mapping : mappings) {
				String outputConn = mapping.get("SCHEMA");
				if (connName.equals(outputConn)) {
					foundMapping = true;
					httpVerb = mapping.get("HTTP_VERB");
					uriPattern = mapping.get("URI_PATTERN");
				}
			}
			if (!foundMapping) {
				continue;
			}
%>
	@javax.ws.rs.<%=httpVerb%>()
<% if (null != uriPattern) { %>
	@javax.ws.rs.Path(<%=uriPattern%>)
<% } %>
	public javax.ws.rs.core.Response <%=connName%>(
			@javax.ws.rs.core.Context javax.ws.rs.core.UriInfo uriInfo, String body) {

		try {
			java.util.Map<String, Object> request = new java.util.HashMap<String, Object>();
			request.put("VERB", "<%=httpVerb%>");
			request.put("OPERATION", "<%=connName%>");
			request.put("URI", uriInfo.getPath());
			request.put("PATTERN", <%=uriPattern%>);
			request.put("PARAMS", getPathParameters(uriInfo));
			request.put("BODY", body);

			QueuedExchangeContextImpl<java.util.Map<String, Object>> messageExchange =
				messageHandler.invoke(request);

			try {
<% if (isOneWay2) { %>
				// return null;
				return javax.ws.rs.core.Response.status(200).build();
<% } else { %>
				java.util.Map<String, Object> responseMap = messageExchange.getResponse();
				String responseBody = (String) responseMap.get("BODY");
				Integer status = (Integer) responseMap.get("STATUS");
				if (null == status) {
					status = 200;
				}

				return javax.ws.rs.core.Response.status(status).entity(responseBody).build();
<% } %>
			} finally {
				messageExchange.completeQueuedProcessing();
			}

		} catch (RuntimeException ex) {
			ex.printStackTrace();
			throw new javax.ws.rs.WebApplicationException(ex, 500);
		} catch (Throwable ex) {
			ex.printStackTrace();
			throw new javax.ws.rs.WebApplicationException(ex, 500);
		} finally {
			// System.out.println(System.currentTimeMillis() + " <- handleMessage");
		}
	}
<%
		}
	}
}
%>
}


class HandlerThread_<%=tHTTPRequestNodeCid%> extends Thread {

	private QueuedMessageHandlerImpl<java.util.Map<String, Object>> handler;

	private final String endpointUrl = <%=ElementParameterParser.getValue(tHTTPRequestNode, "__REST_ENDPOINT__")%>;

	private org.apache.cxf.endpoint.Server server;

	public HandlerThread_<%=tHTTPRequestNodeCid%>(QueuedMessageHandlerImpl<java.util.Map<String, Object>> handler) {
		this.handler = handler;
	}

	public void run() {
		try {
			org.apache.cxf.jaxrs.JAXRSServerFactoryBean sf =
					new org.apache.cxf.jaxrs.JAXRSServerFactoryBean();
			sf.setTransportId("http://cxf.apache.org/transports/http");
			sf.setResourceClasses(RESTProvider_<%=tHTTPRequestNodeCid%>.class);
			sf.setResourceProvider(RESTProvider_<%=tHTTPRequestNodeCid%>.class,
					new org.apache.cxf.jaxrs.lifecycle.SingletonResourceProvider(
							new RESTProvider_<%=tHTTPRequestNodeCid%>(handler)));
			sf.setAddress(endpointUrl);
			server = sf.create();

			System.out.println("rest service [endpoint: " + endpointUrl + "] published");
		} catch (Throwable e) {
			e.printStackTrace();
//			java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
//			e.printStackTrace(new java.io.PrintStream(baos));
//			System.out.println("error:\n" + baos.toString());
		}
	}

	public void stopEndpoint() {
		if (null != server) {
			server.stop();
			server.destroy();
			System.out.println("rest service [endpoint: " + endpointUrl + "] unpublished");
		}
	}
}
<%
}
%>
